/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
//
// Autogenerated by Thrift Compiler (0.22.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
'use strict';

var thrift = require('thrift');
var Thrift = thrift.Thrift;
var Q = thrift.Q;
var Int64 = require('node-int64');

var ttypes = (module.exports = {});
ttypes.ErrorType = {
  CLIENT_ERROR: 0,
  SERVER_ERROR: 1,
};
ttypes.CompressionType = {
  NONE: 0,
  SNAPPY: 1,
};
ttypes.CipherType = {
  AES128: 0,
  AES256: 1,
  SM4: 2,
};
var KeycenterException = (module.exports.KeycenterException = function (args) {
  Thrift.TException.call(this, 'KeycenterException');
  this.name = 'KeycenterException';
  this.message = null;
  this.causeStacktrace = null;
  this.errorType = null;
  if (args) {
    if (args.message !== undefined && args.message !== null) {
      this.message = args.message;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field message is unset!',
      );
    }
    if (args.causeStacktrace !== undefined && args.causeStacktrace !== null) {
      this.causeStacktrace = args.causeStacktrace;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field causeStacktrace is unset!',
      );
    }
    if (args.errorType !== undefined && args.errorType !== null) {
      this.errorType = args.errorType;
    }
  }
});
Thrift.inherits(KeycenterException, Thrift.TException);
KeycenterException.prototype.name = 'KeycenterException';
KeycenterException.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.message = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.causeStacktrace = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.I32) {
          this.errorType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KeycenterException.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('KeycenterException');
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  if (this.causeStacktrace !== null && this.causeStacktrace !== undefined) {
    output.writeFieldBegin('causeStacktrace', Thrift.Type.STRING, 2);
    output.writeString(this.causeStacktrace);
    output.writeFieldEnd();
  }
  if (this.errorType !== null && this.errorType !== undefined) {
    output.writeFieldBegin('errorType', Thrift.Type.I32, 3);
    output.writeI32(this.errorType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmPickKeyPairRequest = (module.exports.HsmPickKeyPairRequest = function (
  args,
) {
  this.sid = null;
  if (args) {
    if (args.sid !== undefined && args.sid !== null) {
      this.sid = args.sid;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field sid is unset!',
      );
    }
  }
});
HsmPickKeyPairRequest.prototype = {};
HsmPickKeyPairRequest.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmPickKeyPairRequest.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmPickKeyPairRequest');
  if (this.sid !== null && this.sid !== undefined) {
    output.writeFieldBegin('sid', Thrift.Type.STRING, 1);
    output.writeString(this.sid);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmPickKeyPairResponse = (module.exports.HsmPickKeyPairResponse = function (
  args,
) {
  this.publicKeyAlgorithm = null;
  this.publicKeyFormat = null;
  this.publicKeyEncoded = null;
  this.privateKeyAlias = null;
  if (args) {
    if (
      args.publicKeyAlgorithm !== undefined &&
      args.publicKeyAlgorithm !== null
    ) {
      this.publicKeyAlgorithm = args.publicKeyAlgorithm;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field publicKeyAlgorithm is unset!',
      );
    }
    if (args.publicKeyFormat !== undefined && args.publicKeyFormat !== null) {
      this.publicKeyFormat = args.publicKeyFormat;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field publicKeyFormat is unset!',
      );
    }
    if (args.publicKeyEncoded !== undefined && args.publicKeyEncoded !== null) {
      this.publicKeyEncoded = args.publicKeyEncoded;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field publicKeyEncoded is unset!',
      );
    }
    if (args.privateKeyAlias !== undefined && args.privateKeyAlias !== null) {
      this.privateKeyAlias = args.privateKeyAlias;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field privateKeyAlias is unset!',
      );
    }
  }
});
HsmPickKeyPairResponse.prototype = {};
HsmPickKeyPairResponse.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.publicKeyAlgorithm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.publicKeyFormat = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.STRING) {
          this.publicKeyEncoded = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 4:
        if (ftype == Thrift.Type.STRING) {
          this.privateKeyAlias = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmPickKeyPairResponse.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmPickKeyPairResponse');
  if (
    this.publicKeyAlgorithm !== null &&
    this.publicKeyAlgorithm !== undefined
  ) {
    output.writeFieldBegin('publicKeyAlgorithm', Thrift.Type.STRING, 1);
    output.writeString(this.publicKeyAlgorithm);
    output.writeFieldEnd();
  }
  if (this.publicKeyFormat !== null && this.publicKeyFormat !== undefined) {
    output.writeFieldBegin('publicKeyFormat', Thrift.Type.STRING, 2);
    output.writeString(this.publicKeyFormat);
    output.writeFieldEnd();
  }
  if (this.publicKeyEncoded !== null && this.publicKeyEncoded !== undefined) {
    output.writeFieldBegin('publicKeyEncoded', Thrift.Type.STRING, 3);
    output.writeBinary(this.publicKeyEncoded);
    output.writeFieldEnd();
  }
  if (this.privateKeyAlias !== null && this.privateKeyAlias !== undefined) {
    output.writeFieldBegin('privateKeyAlias', Thrift.Type.STRING, 4);
    output.writeString(this.privateKeyAlias);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmGetPublicKeyRequest = (module.exports.HsmGetPublicKeyRequest = function (
  args,
) {
  this.sid = null;
  this.keyAlias = null;
  if (args) {
    if (args.sid !== undefined && args.sid !== null) {
      this.sid = args.sid;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field sid is unset!',
      );
    }
    if (args.keyAlias !== undefined && args.keyAlias !== null) {
      this.keyAlias = args.keyAlias;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field keyAlias is unset!',
      );
    }
  }
});
HsmGetPublicKeyRequest.prototype = {};
HsmGetPublicKeyRequest.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.keyAlias = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmGetPublicKeyRequest.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmGetPublicKeyRequest');
  if (this.sid !== null && this.sid !== undefined) {
    output.writeFieldBegin('sid', Thrift.Type.STRING, 1);
    output.writeString(this.sid);
    output.writeFieldEnd();
  }
  if (this.keyAlias !== null && this.keyAlias !== undefined) {
    output.writeFieldBegin('keyAlias', Thrift.Type.STRING, 2);
    output.writeString(this.keyAlias);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmGetPublicKeyResponse = (module.exports.HsmGetPublicKeyResponse =
  function (args) {
    this.publicKeyAlgorithm = null;
    this.publicKeyFormat = null;
    this.publicKeyEncoded = null;
    if (args) {
      if (
        args.publicKeyAlgorithm !== undefined &&
        args.publicKeyAlgorithm !== null
      ) {
        this.publicKeyAlgorithm = args.publicKeyAlgorithm;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field publicKeyAlgorithm is unset!',
        );
      }
      if (args.publicKeyFormat !== undefined && args.publicKeyFormat !== null) {
        this.publicKeyFormat = args.publicKeyFormat;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field publicKeyFormat is unset!',
        );
      }
      if (
        args.publicKeyEncoded !== undefined &&
        args.publicKeyEncoded !== null
      ) {
        this.publicKeyEncoded = args.publicKeyEncoded;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field publicKeyEncoded is unset!',
        );
      }
    }
  });
HsmGetPublicKeyResponse.prototype = {};
HsmGetPublicKeyResponse.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.publicKeyAlgorithm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.publicKeyFormat = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.STRING) {
          this.publicKeyEncoded = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmGetPublicKeyResponse.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmGetPublicKeyResponse');
  if (
    this.publicKeyAlgorithm !== null &&
    this.publicKeyAlgorithm !== undefined
  ) {
    output.writeFieldBegin('publicKeyAlgorithm', Thrift.Type.STRING, 1);
    output.writeString(this.publicKeyAlgorithm);
    output.writeFieldEnd();
  }
  if (this.publicKeyFormat !== null && this.publicKeyFormat !== undefined) {
    output.writeFieldBegin('publicKeyFormat', Thrift.Type.STRING, 2);
    output.writeString(this.publicKeyFormat);
    output.writeFieldEnd();
  }
  if (this.publicKeyEncoded !== null && this.publicKeyEncoded !== undefined) {
    output.writeFieldBegin('publicKeyEncoded', Thrift.Type.STRING, 3);
    output.writeBinary(this.publicKeyEncoded);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmSignRequest = (module.exports.HsmSignRequest = function (args) {
  this.sid = null;
  this.data = null;
  this.privateKeyAlias = null;
  this.algorithm = null;
  if (args) {
    if (args.sid !== undefined && args.sid !== null) {
      this.sid = args.sid;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field sid is unset!',
      );
    }
    if (args.data !== undefined && args.data !== null) {
      this.data = args.data;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field data is unset!',
      );
    }
    if (args.privateKeyAlias !== undefined && args.privateKeyAlias !== null) {
      this.privateKeyAlias = args.privateKeyAlias;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field privateKeyAlias is unset!',
      );
    }
    if (args.algorithm !== undefined && args.algorithm !== null) {
      this.algorithm = args.algorithm;
    }
  }
});
HsmSignRequest.prototype = {};
HsmSignRequest.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.STRING) {
          this.privateKeyAlias = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 4:
        if (ftype == Thrift.Type.STRING) {
          this.algorithm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmSignRequest.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmSignRequest');
  if (this.sid !== null && this.sid !== undefined) {
    output.writeFieldBegin('sid', Thrift.Type.STRING, 1);
    output.writeString(this.sid);
    output.writeFieldEnd();
  }
  if (this.data !== null && this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRING, 2);
    output.writeBinary(this.data);
    output.writeFieldEnd();
  }
  if (this.privateKeyAlias !== null && this.privateKeyAlias !== undefined) {
    output.writeFieldBegin('privateKeyAlias', Thrift.Type.STRING, 3);
    output.writeString(this.privateKeyAlias);
    output.writeFieldEnd();
  }
  if (this.algorithm !== null && this.algorithm !== undefined) {
    output.writeFieldBegin('algorithm', Thrift.Type.STRING, 4);
    output.writeString(this.algorithm);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmSignResponse = (module.exports.HsmSignResponse = function (args) {
  this.signature = null;
  if (args) {
    if (args.signature !== undefined && args.signature !== null) {
      this.signature = args.signature;
    } else {
      throw new Thrift.TProtocolException(
        Thrift.TProtocolExceptionType.UNKNOWN,
        'Required field signature is unset!',
      );
    }
  }
});
HsmSignResponse.prototype = {};
HsmSignResponse.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmSignResponse.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmSignResponse');
  if (this.signature !== null && this.signature !== undefined) {
    output.writeFieldBegin('signature', Thrift.Type.STRING, 1);
    output.writeBinary(this.signature);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmSecretKeyEncryptRequest = (module.exports.HsmSecretKeyEncryptRequest =
  function (args) {
    this.sid = null;
    this.encryptedKey = null;
    this.algorithm = null;
    this.kekAlias = null;
    this.data = null;
    if (args) {
      if (args.sid !== undefined && args.sid !== null) {
        this.sid = args.sid;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field sid is unset!',
        );
      }
      if (args.encryptedKey !== undefined && args.encryptedKey !== null) {
        this.encryptedKey = args.encryptedKey;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encryptedKey is unset!',
        );
      }
      if (args.algorithm !== undefined && args.algorithm !== null) {
        this.algorithm = args.algorithm;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field algorithm is unset!',
        );
      }
      if (args.kekAlias !== undefined && args.kekAlias !== null) {
        this.kekAlias = args.kekAlias;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field kekAlias is unset!',
        );
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = args.data;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field data is unset!',
        );
      }
    }
  });
HsmSecretKeyEncryptRequest.prototype = {};
HsmSecretKeyEncryptRequest.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.encryptedKey = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.STRING) {
          this.algorithm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 4:
        if (ftype == Thrift.Type.STRING) {
          this.kekAlias = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 5:
        if (ftype == Thrift.Type.STRING) {
          this.data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmSecretKeyEncryptRequest.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmSecretKeyEncryptRequest');
  if (this.sid !== null && this.sid !== undefined) {
    output.writeFieldBegin('sid', Thrift.Type.STRING, 1);
    output.writeString(this.sid);
    output.writeFieldEnd();
  }
  if (this.encryptedKey !== null && this.encryptedKey !== undefined) {
    output.writeFieldBegin('encryptedKey', Thrift.Type.STRING, 2);
    output.writeBinary(this.encryptedKey);
    output.writeFieldEnd();
  }
  if (this.algorithm !== null && this.algorithm !== undefined) {
    output.writeFieldBegin('algorithm', Thrift.Type.STRING, 3);
    output.writeString(this.algorithm);
    output.writeFieldEnd();
  }
  if (this.kekAlias !== null && this.kekAlias !== undefined) {
    output.writeFieldBegin('kekAlias', Thrift.Type.STRING, 4);
    output.writeString(this.kekAlias);
    output.writeFieldEnd();
  }
  if (this.data !== null && this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRING, 5);
    output.writeBinary(this.data);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmSecretKeyEncryptResponse = (module.exports.HsmSecretKeyEncryptResponse =
  function (args) {
    this.iv = null;
    this.encryptedData = null;
    if (args) {
      if (args.iv !== undefined && args.iv !== null) {
        this.iv = args.iv;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field iv is unset!',
        );
      }
      if (args.encryptedData !== undefined && args.encryptedData !== null) {
        this.encryptedData = args.encryptedData;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encryptedData is unset!',
        );
      }
    }
  });
HsmSecretKeyEncryptResponse.prototype = {};
HsmSecretKeyEncryptResponse.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.iv = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.encryptedData = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmSecretKeyEncryptResponse.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmSecretKeyEncryptResponse');
  if (this.iv !== null && this.iv !== undefined) {
    output.writeFieldBegin('iv', Thrift.Type.STRING, 1);
    output.writeBinary(this.iv);
    output.writeFieldEnd();
  }
  if (this.encryptedData !== null && this.encryptedData !== undefined) {
    output.writeFieldBegin('encryptedData', Thrift.Type.STRING, 2);
    output.writeBinary(this.encryptedData);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmSecretKeyDecryptRequest = (module.exports.HsmSecretKeyDecryptRequest =
  function (args) {
    this.sid = null;
    this.encryptedKey = null;
    this.algorithm = null;
    this.kekAlias = null;
    this.iv = null;
    this.encryptedData = null;
    if (args) {
      if (args.sid !== undefined && args.sid !== null) {
        this.sid = args.sid;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field sid is unset!',
        );
      }
      if (args.encryptedKey !== undefined && args.encryptedKey !== null) {
        this.encryptedKey = args.encryptedKey;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encryptedKey is unset!',
        );
      }
      if (args.algorithm !== undefined && args.algorithm !== null) {
        this.algorithm = args.algorithm;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field algorithm is unset!',
        );
      }
      if (args.kekAlias !== undefined && args.kekAlias !== null) {
        this.kekAlias = args.kekAlias;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field kekAlias is unset!',
        );
      }
      if (args.iv !== undefined && args.iv !== null) {
        this.iv = args.iv;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field iv is unset!',
        );
      }
      if (args.encryptedData !== undefined && args.encryptedData !== null) {
        this.encryptedData = args.encryptedData;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encryptedData is unset!',
        );
      }
    }
  });
HsmSecretKeyDecryptRequest.prototype = {};
HsmSecretKeyDecryptRequest.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.encryptedKey = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.STRING) {
          this.algorithm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 4:
        if (ftype == Thrift.Type.STRING) {
          this.kekAlias = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 5:
        if (ftype == Thrift.Type.STRING) {
          this.iv = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 6:
        if (ftype == Thrift.Type.STRING) {
          this.encryptedData = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmSecretKeyDecryptRequest.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmSecretKeyDecryptRequest');
  if (this.sid !== null && this.sid !== undefined) {
    output.writeFieldBegin('sid', Thrift.Type.STRING, 1);
    output.writeString(this.sid);
    output.writeFieldEnd();
  }
  if (this.encryptedKey !== null && this.encryptedKey !== undefined) {
    output.writeFieldBegin('encryptedKey', Thrift.Type.STRING, 2);
    output.writeBinary(this.encryptedKey);
    output.writeFieldEnd();
  }
  if (this.algorithm !== null && this.algorithm !== undefined) {
    output.writeFieldBegin('algorithm', Thrift.Type.STRING, 3);
    output.writeString(this.algorithm);
    output.writeFieldEnd();
  }
  if (this.kekAlias !== null && this.kekAlias !== undefined) {
    output.writeFieldBegin('kekAlias', Thrift.Type.STRING, 4);
    output.writeString(this.kekAlias);
    output.writeFieldEnd();
  }
  if (this.iv !== null && this.iv !== undefined) {
    output.writeFieldBegin('iv', Thrift.Type.STRING, 5);
    output.writeBinary(this.iv);
    output.writeFieldEnd();
  }
  if (this.encryptedData !== null && this.encryptedData !== undefined) {
    output.writeFieldBegin('encryptedData', Thrift.Type.STRING, 6);
    output.writeBinary(this.encryptedData);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmSecretKeyDecryptResponse = (module.exports.HsmSecretKeyDecryptResponse =
  function (args) {
    this.data = null;
    if (args) {
      if (args.data !== undefined && args.data !== null) {
        this.data = args.data;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field data is unset!',
        );
      }
    }
  });
HsmSecretKeyDecryptResponse.prototype = {};
HsmSecretKeyDecryptResponse.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmSecretKeyDecryptResponse.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmSecretKeyDecryptResponse');
  if (this.data !== null && this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRING, 1);
    output.writeBinary(this.data);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmPrivateKeyDecryptRequest = (module.exports.HsmPrivateKeyDecryptRequest =
  function (args) {
    this.sid = null;
    this.encryptedData = null;
    this.keyAlias = null;
    this.algorithm = null;
    if (args) {
      if (args.sid !== undefined && args.sid !== null) {
        this.sid = args.sid;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field sid is unset!',
        );
      }
      if (args.encryptedData !== undefined && args.encryptedData !== null) {
        this.encryptedData = args.encryptedData;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encryptedData is unset!',
        );
      }
      if (args.keyAlias !== undefined && args.keyAlias !== null) {
        this.keyAlias = args.keyAlias;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field keyAlias is unset!',
        );
      }
      if (args.algorithm !== undefined && args.algorithm !== null) {
        this.algorithm = args.algorithm;
      }
    }
  });
HsmPrivateKeyDecryptRequest.prototype = {};
HsmPrivateKeyDecryptRequest.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 2:
        if (ftype == Thrift.Type.STRING) {
          this.encryptedData = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 3:
        if (ftype == Thrift.Type.STRING) {
          this.keyAlias = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      case 4:
        if (ftype == Thrift.Type.STRING) {
          this.algorithm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmPrivateKeyDecryptRequest.prototype[Symbol.for('write')] = function (output) {
  output.writeStructBegin('HsmPrivateKeyDecryptRequest');
  if (this.sid !== null && this.sid !== undefined) {
    output.writeFieldBegin('sid', Thrift.Type.STRING, 1);
    output.writeString(this.sid);
    output.writeFieldEnd();
  }
  if (this.encryptedData !== null && this.encryptedData !== undefined) {
    output.writeFieldBegin('encryptedData', Thrift.Type.STRING, 2);
    output.writeBinary(this.encryptedData);
    output.writeFieldEnd();
  }
  if (this.keyAlias !== null && this.keyAlias !== undefined) {
    output.writeFieldBegin('keyAlias', Thrift.Type.STRING, 3);
    output.writeString(this.keyAlias);
    output.writeFieldEnd();
  }
  if (this.algorithm !== null && this.algorithm !== undefined) {
    output.writeFieldBegin('algorithm', Thrift.Type.STRING, 4);
    output.writeString(this.algorithm);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var HsmPrivateKeyDecryptResponse =
  (module.exports.HsmPrivateKeyDecryptResponse = function (args) {
    this.data = null;
    if (args) {
      if (args.data !== undefined && args.data !== null) {
        this.data = args.data;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field data is unset!',
        );
      }
    }
  });
HsmPrivateKeyDecryptResponse.prototype = {};
HsmPrivateKeyDecryptResponse.prototype[Symbol.for('read')] = function (input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == Thrift.Type.STRING) {
          this.data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

HsmPrivateKeyDecryptResponse.prototype[Symbol.for('write')] = function (
  output,
) {
  output.writeStructBegin('HsmPrivateKeyDecryptResponse');
  if (this.data !== null && this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRING, 1);
    output.writeBinary(this.data);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};
